{"version":3,"file":"figma-transformer.cjs.production.min.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["import { Node } from \"figma-js\";\nimport { Shortcut } from \"./types\";\n\nfunction uniqBy(arr: any[], fn: string, set = new Set()) {\n    return arr.filter(el => (v => !set.has(v) && set.add(v))(el[fn]));\n}\n\nfunction groupBy(arr: any[], key: string) {\n    return arr.reduce(function(rv, x) {\n        (rv[x[key]] = rv[x[key]] || []).push(x);\n        return rv;\n    }, {});\n}\n\nexport const groupNodes = (nodes: Node[]): Record<Shortcut, Node[]> =>\n    groupBy(uniqBy(nodes, \"id\"), \"type\");\n","import {\n    Document,\n    FileResponse,\n    Style,\n    ComponentMetadata,\n    Node,\n} from \"figma-js\";\nimport { groupNodes } from \"./utils\";\nimport { ProcessedFile } from \"./types\";\n\nexport function processFile(data: FileResponse, id: string): ProcessedFile {\n    const {\n        name,\n        lastModified,\n        thumbnailUrl,\n        version,\n        document,\n        styles,\n        components,\n    } = data;\n\n    const [processedNodes, processedShortcuts] = processNodes(\n        document,\n        styles,\n        components,\n        id\n    );\n\n    return {\n        fileId: id,\n        name,\n        lastModified,\n        thumbnailUrl,\n        version,\n        children: processedNodes[0].children,\n        shortcuts: groupNodes(processedShortcuts),\n    };\n}\n\nexport function processNodes(\n    nodes: Document,\n    documentStyles: { [key: string]: Style },\n    components: { [key: string]: ComponentMetadata },\n    fileId: string\n) {\n    const parsedStyles = new Map(Object.entries(documentStyles));\n    const parsedComponents = new Map(Object.entries(components));\n\n    const traverseChildren = (node: any, parentId: string) => {\n        const { id, styles, children, ...rest } = node;\n        let nodeStyles: any[] = [];\n\n        // If node has styles definitions populate that with the actual styles\n        if (styles != null) {\n            nodeStyles = Object.entries(styles).map(([key, styleId]) => {\n                const documentStyle = parsedStyles.get(styleId as string);\n\n                return {\n                    id: styleId,\n                    ...documentStyle,\n                    styles: node[`${key}s`],\n                    typeStyles: node.style,\n                    type: \"STYLE\",\n                };\n            });\n        }\n\n        // Reached a leaf so returning the simplified node\n        if (children == null || children.length === 0) {\n            return [[{ id, parentId, fileId, ...rest }], nodeStyles];\n        }\n\n        // If it gets here then it means it has children\n        // so we're going to recursively go through them\n        // and combine everything\n        const [parsedChildren, shortcuts] = children.reduce(\n            (acc: [Node[], Node[]], child: Node) => {\n                const [accChildren, accShortcuts] = acc;\n                const [tChildren, tShortcuts] = traverseChildren(child, id);\n                return [\n                    [...accChildren, ...tChildren],\n                    [...accShortcuts, ...tChildren, ...tShortcuts],\n                ];\n            },\n            [[], []]\n        );\n\n        const componentInfo = parsedComponents.get(id);\n\n        // Finally we return the parsed node with the\n        // parsed children grouped by type\n        const parsedNode = {\n            id,\n            parentId,\n            fileId,\n            ...rest,\n            ...(componentInfo && componentInfo),\n            children: parsedChildren,\n            shortcuts: groupNodes(shortcuts),\n        };\n\n        return [[parsedNode], shortcuts];\n    };\n\n    return traverseChildren(nodes, \"0:0\");\n}\n"],"names":["groupNodes","nodes","arr","key","reduce","rv","x","push","groupBy","set","Set","filter","el","has","v","add","processNodes","documentStyles","components","fileId","parsedStyles","Map","Object","entries","parsedComponents","traverseChildren","node","parentId","id","styles","children","rest","nodeStyles","map","styleId","get","typeStyles","style","type","length","acc","child","accChildren","accShortcuts","tChildren","tShortcuts","parsedChildren","shortcuts","componentInfo","data","name","lastModified","thumbnailUrl","version","document"],"mappings":"4NAcO,IAAMA,EAAc,SAAAC,UAP3B,SAAiBC,EAAYC,UAClBD,EAAIE,QAAO,SAASC,EAAIC,UAC1BD,EAAGC,EAAC,MAASD,EAAGC,EAAC,OAAU,IAAIC,KAAKD,GAC9BD,IACR,IAIHG,EAZYN,EAYGD,WAZqBQ,IAAAA,EAAM,IAAIC,KACvCR,EAAIS,QAAO,SAAAC,UAAaH,EAAII,IAAVC,EAAgCF,EAAE,KAAdH,EAAIM,IAAID,GAA5B,IAAAA,WADbZ,EAAwBO,GCoCxC,SAAgBO,EACZf,EACAgB,EACAC,EACAC,OAEMC,EAAe,IAAIC,IAAIC,OAAOC,QAAQN,IACtCO,EAAmB,IAAIH,IAAIC,OAAOC,QAAQL,WAEvB,SAAnBO,EAAoBC,EAAWC,OACzBC,EAAkCF,EAAlCE,GAAIC,EAA8BH,EAA9BG,OAAQC,EAAsBJ,EAAtBI,SAAaC,qIAASL,8BACtCM,EAAoB,MAGV,MAAVH,IACAG,EAAaV,OAAOC,QAAQM,GAAQI,KAAI,gBAAE9B,OAAK+B,iBAIvCN,GAAIM,GAHcd,EAAae,IAAID,IAKnCL,OAAQH,EAAQvB,OAChBiC,WAAYV,EAAKW,MACjBC,KAAM,cAMF,MAAZR,GAAwC,IAApBA,EAASS,aACtB,CAAC,IAAGX,GAAAA,EAAID,SAAAA,EAAUR,OAAAA,GAAWY,IAASC,SAMbF,EAAS1B,QACzC,SAACoC,EAAuBC,OACbC,EAA6BF,KAAhBG,EAAgBH,OACJf,EAAiBgB,EAAOb,GAAjDgB,OAAWC,aACX,WACCH,EAAgBE,aAChBD,EAAiBC,EAAcC,MAG3C,CAAC,GAAI,KATFC,OAAgBC,OAYjBC,EAAgBxB,EAAiBW,IAAIP,SAcpC,CAAC,IATJA,GAAAA,EACAD,SAAAA,EACAR,OAAAA,GACGY,KACCiB,GAAiBA,GACrBlB,SAAUgB,EACVC,UAAW/C,EAAW+C,MAGJA,GAGnBtB,CAAiBxB,EAAO,2BA9F7B,SAAsBgD,EAAoBrB,OAExCsB,EAOAD,EAPAC,KACAC,EAMAF,EANAE,aACAC,EAKAH,EALAG,aACAC,EAIAJ,EAJAI,UAMyCrC,EAFzCiC,EAHAK,SAGAL,EAFApB,OAEAoB,EADA/B,WAOAU,SAGG,CACHT,OAAQS,EACRsB,KAAAA,EACAC,aAAAA,EACAC,aAAAA,EACAC,QAAAA,EACAvB,cAAyB,GAAGA,SAC5BiB,UAAW/C"}